package leetcodehot100;

/*
给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。
假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。
你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

示例 1：
输入：nums = [1,3,4,2,2]
输出：2

示例 2：
输入：nums = [3,1,3,4,2]
输出：3

示例 3 :
输入：nums = [3,3,3,3,3]
输出：3
 */

/*
使用“快慢指针”技巧，这类似于在链表中寻找环的入口。
我们将数组视为一个循环链表，重复的数字即为环的入口。
我们可以设置两个指针，一个快一个慢，快指针一次移动两步，慢指针一次移动一步。由于存在重复的数字，所以快慢指针最终会在环内相遇。
然后我们可以将一个指针重新设置为数组的起始点，并让两个指针以相同的速度移动，它们将在环的入口，也就是重复的数字处相遇。
 */
/*
输入：nums = [1,3,4,2,2]
输出：2
nums[0] = 1，这意味着从 nums[0] 出发，下一个元素是 nums[1]。
nums[1] = 3，这意味着从 nums[1] 出发，下一个元素是 nums[3]。
nums[3] = 2，这意味着从 nums[3] 出发，下一个元素是 nums[2]。
nums[2] = 4，这意味着从 nums[2] 出发，下一个元素是 nums[4]。
nums[4] = 2，这意味着从 nums[4] 出发，下一个元素是 nums[2]。
 nums[0]->nums[1]->nums[3]->nums[2]->nums[4]
                                 ⬆️      |
                                 |------|
 */
class Solution287 {
    /**
     * 查找数组中唯一的重复数字。
     *
     * @param nums 包含 n + 1 个整数的数组，数字范围在 [1, n] 内。
     * @return 数组中唯一的重复数字。
     */
    public int findDuplicate(int[] nums) {
        // 初始化慢指针和快指针，都从数组起始位置开始
        int slow = 0, fast = 0;
        //slow和fast都代表的下一个索引 比如nums[0]=1 那么nums[0]=1下一个就是nums[1]
        // 快慢指针相遇，即找到环内的一个点
        do {
            // 慢指针每次移动一步
            slow = nums[slow];
            // 快指针每次移动两步
            fast = nums[nums[fast]];
        } while (slow != fast);
        /*
        在快慢指针第一次相遇后，slow 指针所处的位置是环内的一个点，而不是环的入口。如果直接返回 nums[slow]，得到的并不是重复的数字。
        正确的做法是，将 slow 指针重新置为数组起始位置，然后让 slow 和 fast 指针以相同速度移动，当它们再次相遇时，相遇点就是环的入口，也就是重复的数字。
         */
//        return nums[slow];
        // 慢指针回到数组起始位置
        slow = 0;
        // 快慢指针以相同速度移动，再次相遇的位置即为环的入口，也就是重复数字
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        // 返回重复数字
        return slow;
    }

    public static void main(String[] args) {
        new Solution287().findDuplicate(new int[]{1, 3, 4, 2, 2});
    }
}