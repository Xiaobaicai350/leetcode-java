package leetcodehot100;

/*
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。
 */
class Solution41 {
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            //前两个条件是要满足是1-len的正整数，然后再交换位置
            //需要注意的是这里必须用while，因为需要再次检查当前位置是否是合理的，我们交换只检查了i,但是没有检查交换后的值
            while (nums[i] >= 1 && nums[i] <= len
                    && nums[i] != i + 1) {
                swap(nums, i, nums[i] - 1);
            }
        }
        for (int i = 0; i < len; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return len + 1;
    }

    // 交换函数
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }


    /*
使用 while 循环的情况
    第一次循环（i = 0）
    当前元素 nums[0] = 3，3 是 1 到 4 范围内的正整数，且 3 不在正确的位置（nums[0] != 0 + 1）。
    执行交换操作，将 3 放到 nums[2] 的位置，数组变为 [ -1, 4, 3, 1 ]。
    由于 nums[0] = -1 不满足 while 条件，跳出 while 循环。
    第二次循环（i = 1）
    当前元素 nums[1] = 4，4 是 1 到 4 范围内的正整数，且 4 不在正确的位置（nums[1] != 1 + 1）。
    执行交换操作，将 4 放到 nums[3] 的位置，数组变为 [ -1, 1, 3, 4 ]。
    此时 nums[1] = 1，但 1 不在正确的位置（nums[1] != 1 + 1），继续执行 while 循环。
    再次执行交换操作，将 1 放到 nums[0] 的位置，数组变为 [ 1, -1, 3, 4 ]。
    此时 nums[1] = -1 不满足 while 条件，跳出 while 循环。
    第三次循环（i = 2）
    当前元素 nums[2] = 3，3 已经在正确的位置（nums[2] == 2 + 1），不满足 while 条件，跳过 while 循环。
    第四次循环（i = 3）
    当前元素 nums[3] = 4，4 已经在正确的位置（nums[3] == 3 + 1），不满足 while 条件，跳过 while 循环。
    最终数组变为 [ 1, -1, 3, 4 ]，接着遍历数组，找到第一个 nums[i] != i + 1 的位置，返回 i + 1，即 2。
使用 if 循环的情况
    第一次循环（i = 0）
    当前元素 nums[0] = 3，3 是 1 到 4 范围内的正整数，且 3 不在正确的位置（nums[0] != 0 + 1）。
    执行交换操作，将 3 放到 nums[2] 的位置，数组变为 [ -1, 4, 3, 1 ]。
    由于使用 if 语句，只执行一次交换操作，不会再次检查当前位置。
    第二次循环（i = 1）
    当前元素 nums[1] = 4，4 是 1 到 4 范围内的正整数，且 4 不在正确的位置（nums[1] != 1 + 1）。
    执行交换操作，将 4 放到 nums[3] 的位置，数组变为 [ -1, 1, 3, 4 ]。
    同样，只执行一次交换操作，不会再次检查当前位置。
    第三次循环（i = 2）
    当前元素 nums[2] = 3，3 已经在正确的位置（nums[2] == 2 + 1），跳过 if 语句。
    第四次循环（i = 3）
    当前元素 nums[3] = 4，4 已经在正确的位置（nums[3] == 3 + 1），跳过 if 语句。
    最终数组变为 [ -1, 1, 3, 4 ]，接着遍历数组，找到第一个 nums[i] != i + 1 的位置，返回 i + 1，即 2。不过，在某些情况下，使用 if 语句可能无法得到正确结果。
    例如，输入数组 nums = [3, 4, -1, 1, 2]，使用 if 语句就可能无法把所有元素放到正确位置，而使用 while 循环就能保证所有元素都在正确位置。
    综上所述，使用 while 循环是为了确保每个位于 1 到 len 范围内的正整数都能被放到正确的位置上，从而保证算法的正确性。
     */
}