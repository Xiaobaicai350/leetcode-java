package leetcodehot100;

/*
整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。
例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。
如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3,4] 的下一个排列是 [1,2,4,3] 。这个排列怎么找下一个记住就可以啦
1.从右向左查找第一个递减的元素： 从数组的末尾开始向前查找，找到第一个递减的元素。在 [1, 2, 3, 4] 中，从右向左第一个递减的元素是 3。
2.从右向左查找第一个大于该元素的元素： 从数组的末尾开始向前查找，找到第一个大于 3 的元素。在 [1, 2, 3, 4] 中，从右向左第一个大于 3 的元素是 4。
3.交换这两个元素： 将找到的两个元素 3 和 4 进行交换，得到 [1, 2, 4, 3]。
4.反转交换位置之后的所有元素： 在交换位置之后，需要将交换位置之后的所有元素进行反转。 这时候i=2 所以反转的区间是[3,3]. 所以只反转3 还是3

示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]

示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]
 */
public class Solution31 {
    //给你一个整数数组 nums ，找出 nums 的下一个排列。
    public void nextPermutation(int[] nums) {
        //数组倒数第二个下标
        int i = nums.length - 2;
        // 1.从右往左查找，找到第一个递减的元素
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }

        //2. 从右向左查找第一个大于该元素的元素
        if (i >= 0) {//这里不满足说明这个排列就是目前最大的了，需要把它变成最小的也就是[3,2,1]-》[1,2,3]
            int j = nums.length - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            //3.交换这两个元素：
            swap(nums, i, j);
        }

        // 4.反转交换位置之后的所有元素
        reverse(nums, i + 1, nums.length - 1);
    }

    // 用于交换数组中的两个元素
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    // 反转数组的一部分
    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            swap(nums, start, end);
            start++;
            end--;
        }
    }

    public static void main(String[] args) {
        new Solution31().nextPermutation(new int[]{1, 2, 4, 3}); //1,3,4,2   //1,3,2,4
    }

}

